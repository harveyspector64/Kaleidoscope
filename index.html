<!DOCTYPE html>
<html>
<head>
  <title>Authentic Kaleidoscope Experience</title>
  <style>
    canvas {
      display: block;
      margin: 0 auto;
    }
    .controls {
      text-align: center;
      margin-top: 20px;
    }
  </style>
</head>
<body>
  <canvas id="kaleidoscope"></canvas>
  <div class="controls">
    <label for="segments">Segments:</label>
    <input type="range" id="segments" min="4" max="12" step="2" value="6">
    <label for="speed">Rotation Speed:</label>
    <input type="range" id="speed" min="0.1" max="2" step="0.1" value="1">
  </div>

  <script>
    const canvas = document.getElementById('kaleidoscope');
    const ctx = canvas.getContext('2d');
    const segmentsInput = document.getElementById('segments');
    const speedInput = document.getElementById('speed');

    let shapes = [];
    let numSegments = 6;
    let rotationSpeed = 1;
    let rotationAngle = 0;
    let isDragging = false;
    let lastX = 0;
    let lastY = 0;

    const colors = [
      '#FF6B6B', '#FFD93D', '#6BCB77', '#4D96FF', '#6F69AC', '#FFB2FF',
      '#FF7F50', '#FFD700', '#50C878', '#1E90FF', '#9370DB', '#FF69B4'
    ];

    function getRandomColor() {
      return colors[Math.floor(Math.random() * colors.length)];
    }

    function createShapes() {
      shapes = [];
      for (let i = 0; i < 20; i++) {
        const shape = {
          x: Math.random() * canvas.width / 2,
          y: Math.random() * canvas.height / 2,
          size: 10 + Math.random() * 40,
          color: getRandomColor(),
          angle: Math.random() * Math.PI * 2,
          speed: 0.01 + Math.random() * 0.05
        };
        shapes.push(shape);
      }
    }

    function drawShapes() {
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      const radius = Math.min(centerX, centerY) * 0.8;
      const segmentAngle = (Math.PI * 2) / numSegments;

      ctx.save();
      ctx.translate(centerX, centerY);
      ctx.rotate(rotationAngle);

      for (let i = 0; i < numSegments; i++) {
        ctx.save();
        ctx.rotate(i * segmentAngle);

        for (let j = 0; j < shapes.length; j++) {
          const shape = shapes[j];

          ctx.fillStyle = shape.color;
          ctx.beginPath();
          ctx.arc(shape.x, shape.y, shape.size, 0, Math.PI * 2);
          ctx.fill();

          // Mirroring effect
          ctx.save();
          ctx.scale(-1, 1);
          ctx.fill();
          ctx.restore();
        }

        ctx.restore();
      }

      ctx.restore();
    }

    function updateShapes() {
      for (let i = 0; i < shapes.length; i++) {
        const shape = shapes[i];
        shape.angle += shape.speed * rotationSpeed;
        shape.x = Math.cos(shape.angle) * (canvas.width / 4);
        shape.y = Math.sin(shape.angle) * (canvas.height / 4);
      }
    }

    function animate() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      updateShapes();
      drawShapes();
      requestAnimationFrame(animate);
    }

    function onMouseDown(e) {
      isDragging = true;
      lastX = e.clientX || e.touches[0].clientX;
      lastY = e.clientY || e.touches[0].clientY;
    }

    function onMouseMove(e) {
      if (!isDragging) return;

      const currentX = e.clientX || e.touches[0].clientX;
      const currentY = e.clientY || e.touches[0].clientY;
      const deltaX = currentX - lastX;
      const deltaY = currentY - lastY;

      rotationAngle += (deltaX + deltaY) * 0.01;

      lastX = currentX;
      lastY = currentY;
    }

    function onMouseUp() {
      isDragging = false;
    }

    canvas.addEventListener('mousedown', onMouseDown);
    canvas.addEventListener('mousemove', onMouseMove);
    canvas.addEventListener('mouseup', onMouseUp);
    canvas.addEventListener('touchstart', onMouseDown);
    canvas.addEventListener('touchmove', onMouseMove);
    canvas.addEventListener('touchend', onMouseUp);

    segmentsInput.addEventListener('input', function() {
      numSegments = parseInt(segmentsInput.value);
    });

    speedInput.addEventListener('input', function() {
      rotationSpeed = parseFloat(speedInput.value);
    });

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }

    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    createShapes();
    animate();
  </script>
</body>
</html>
